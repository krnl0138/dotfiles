What I've learned in Bash
=========================

${toc}

## Main Tips

- Bash cheatsheet: https://devhints.io/bash
- You can safely use "[[" instead of "[" whenever possible
- `REPLY` is the default variable for the read built-in.
- Use `set -x` and `set +x` to debug code via `bash -x` flag
- `LINENO` is the line number in the script or shell function currently executing. Maybe helpful for error handling
- Use in scripts `> /dev/null 2>&1` to supress any output. Errors are redirected to main, which is going to be purged
- Anything in `()` (group commands) (and pipe also) is distinct from a shell and dies after execution, to avoid this behavior and to use current shell type `${ list; }`
- Use `declare -A arrayname` to get associative array (like dict in python, `array[key]=value`)
- To feed 'file' to 'list' use `list < file`
- `>(list)` and `<(list)` to treat an output of a command as a file

## Using $ Variable

Character|Definition
---------|----------
$*| Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, it expands to a single word with the value of each parameter separated by the first character of the IFS special variable.
$@| Expands to the positional parameters, starting from one. When the expansion occurs within double quotes, each parameter expands to a separate word.
$#| Expands to the number of positional parameters in decimal.
$?| Expands to the exit status of the most recently executed foreground pipeline.
$-| A hyphen expands to the current option flags as specified upon invocation, by the set built-in command, or those set by the shell itself (such as the -i).
$$| Expands to the process ID of the shell.
$!| Expands to the process ID of the most recently executed background (asynchronous) command.
$0| Expands to the name of the shell or shell script.
$_| The underscore variable is set at shell startup and contains the absolute file name of the shell or script being executed as passed in the argument list. Subsequently, it expands to the last argument to the previous command, after expansion. It is also set to the full pathname of each command executed and placed in the environment exported to that command. When checking mail, this parameter holds the name of the mail file


## Using associative arrays

Definition|Character
---------|----------
Assign an array by elements|`declare -A array=( [item]=cheese [price]=6.75 )`
Add to or modify elements in an array|`array+=( [type]="fresh curds" )`
Copy array|`declare -n array2=array`
List array keys|`echo "${!array[@]}"`
List array values|`echo "${array[@]}"`

## GETOPTS in Bash
https://www.computerhope.com/unix/bash/getopts.htm
https://stackoverflow.com/questions/402377/using-getopts-to-process-long-and-short-command-line-options

- Bash builtin getopts. This does not support long option names with the double-dash prefix. It only supports single-character options.
- BSD UNIX implementation of standalone getopt command (which is what MacOS uses). This does not support long options either.
- GNU implementation of standalone getopt. GNU getopt(3) (used by the command-line getopt(1) on Linux) supports parsing long options.

```
usage() {                                      # Function: Print a help message.
  echo "Usage: $0 [ -s SEC ] [ -m MIN ] [ -h HRS ] [ -l MESSAGE ]" 1>&2
}
exit_abnormal() {                              # Function: Exit with error.
  usage
  exit 1
}
# Loop: Get the next option;
# use silent error checking;
# options n and t take arguments.
while getopts ":s:m:h:l:" options; do
  case "${options}" in                         #
    s)                                         # If the option is n,
      PERIOD=${OPTARG}                         # set $NAME to specified value.
      period_check "$PERIOD"
      ;;
    m)                                         # If the option is t,
      PERIOD=${OPTARG}                         # Set $TIMES to specified value.
      period_check "$PERIOD"
      PERIOD=$((PERIOD*60))                    # Set $TIMES to specified value.
      ;;
    h)                                         # If the option is n,
      PERIOD=${OPTARG}                         # Set $TIMES to specified value.
      period_check "$PERIOD"
      PERIOD=$((PERIOD*3600))                  # Set $TIMES to specified value.
      ;;
    l)                                         # If the option is n,
      MESSAGE=${OPTARG}                        # Set $TIMES to specified value.
      ;;
    :)                                         # If expected argument omitted:
      echo "Error: -${OPTARG} requires an argument."
      exit_abnormal                            # Exit abnormally.
      ;;
    *)                                         # If unknown (any other) option:
      exit_abnormal                            # Exit abnormally.
      ;;
  esac
done
```

## Snippets

'For' loop basic usage
```
#!/bin/sh
for NUM in `seq 1 1 1000`; do touch $NUM-file.txt; done
```

Subsitute inside a variable
```
#!/bin/sh
name="Derek"
# Use variable expansion to protect the variable
echo "${name}'s toy"
# Subsitute inside a variable
echo "${name//e/o}"
```

Get promt
```
#!/bin/sh
# Get promt
read -rp "How old are you?" age
echo "$age"
# Check if it greater then
# -gt -lt -eq -ne -le
if [ "$age" -gt 10 ]; then
    echo "Hello, you're older than 10"
fi
```

Use file command on $files
```
#!/bin/sh
# Use file command on $files
i=0
while [ $i -lt 10 ]; do
    file "./file0${i}"
    i=$((i+1))
done
```


Find on server file that belongs to group/user and is 33 bytes without
```
#!/bin/sh
# Find on server file that belongs to group/user and is 33 bytes without
# error messages
find / -user bandit7 -a -group bandit6 -a -size 33c 2>/dev/null
```

Work with 'TRAP' and 'SIG'
```
#!/bin/sh
# How to work with 'TRAP' and 'SIG'
# Program to print a text file with headers and footers
TEMP_FILE=/tmp/printfile.txt
#If get one of the following signals execute rm
trap "rm $TEMP_FILE; exit" SIGHUP SIGINT SIGTERM
pr $1 > $TEMP_FILE
echo -n "Print file? [y/n]: "
read
if [ "$REPLY" = "y" ]; then
    lpr $TEMP_FILE
fi
rm $TEMP_FILE
```

Text modification with Sed, AWK and basic checks
```
#!/bin/sh
# This scripts find data for 'Russia' in Corona-cli widget
# Check if file was not modified today and curl new version
[ "$(stat ~/tmp/corona | grep "Change" | cut -d' ' -f2)" != "$(date +%Y-%m-%d)" ] &&
    curl -s "https://corona-stats.online?source=2" > ~/tmp/corona
# Modify string from grep
grep --color=never "Russia" "$HOME/tmp/corona" |
    sed "s/\s//g ; s/â”‚/;/g" |
    awk -F';' '{print "cases "$3 " rec "$7 " deaths "$5}'
```

While loop basic form
```
#!/bin/sh
i=0
while [ $i -lt 10 ]; do
    file "./file0${i}"
    i=$((i+1))
done
```

##  20 Bash exercises
https://medium.com/@sankad_19852/shell-scripting-exercises-5eb7220c2252

EXERCISE 1
```
#!/bin/sh
NAME=$(hostname)
echo "This script is running on $NAME"
```

EXERCISE 2
```
#!/bin/sh
[ -f file_path ] || touch file_path && echo "file_path passwords are enabled"
[ -w file_path ] && echo "You have permissions to edit file_path" || echo "You do NOT have permissions to edit file_path"
```

EXERCISE 3
```
#!/bin/sh
echo -e "man\nbear\npig\ndog\ncat\nsheep"
```

EXERCISE 4
```
#!/bin/sh
read -p "Enter path to check : " dir
file $dir
ls -l $dir
```

EXERCISE 5
```
#!/bin/sh
FILES=$@
for file in $FILES; do
    if [ -f "$file" ]; then
        echo ""$file" is a file"
    elif [ -d $flie ]; then
        echo ""$file" is a directory"
    else
        echo ""$file" is another type of a file"
    fi
    ls -l $file
done
```

EXERCISE 6
```
#!/bin/sh
echo "this script exits with 0 code status"
exit 0
```

EXERCISE 7
```
#!/bin/sh
cat /etc/shadow
[ "$?" -eq "0" ] && echo "Command succeeded" && exit 0 || echo "Command failed" && exit 1
```

EXERCISE 8
```
#!/bin/sh
function files_count(){
    # this line uses incoming parameter as a $1 parameter
    local num_files=$(ls -l $1 | wc -l)
    echo "There are $num_files files in $1 directory"
}
# this line evokes function with parameter from prompt
files_count $1
```

EXERCISE 9
```
#!/bin/sh
rename_jpg(){
    cd $1
    for file in $(ls ../$1); do
        # Quoting will not work here
        # https://stackoverflow.com/questions/18709962/regex-matching-in-a-bash-if-statement/18710850
        if [[ $file =~ .jpg$ ]] && [[ -f $file ]]; then
            mv ${file} $(date +%F)-${file}
        else
            echo "no .jpg files in folder"
        fi
    done
}
rename_jpg $1
```

EXERCISE 10
```
#!/bin/sh
rename_file(){
    local home_dir=$1
    local pref_png=$prefix_png
    local pref_jpg=$prefix_jpg
    cd $home_dir
    for file in $(ls .); do
        echo -e "\ncurrent file for renaming is $file"
        # Quoting will not work here
        # https://stackoverflow.com/questions/18709962/regex-matching-in-a-bash-if-statement/18710850
        if [[ $file =~ .png$ && -f $file ]]; then
            mv ${file} ${pref_png}-${file}
        elif [[ $file =~ .jpg$ && -f $file ]]; then
            mv ${file} ${pref_jpg}-${file}
        else
            echo "$file is neither .jpg or .png file"
        fi
    done
}
read -p "Which prefix use for .png files : " prefix_png
read -p "Which prefix use for .jpg files : " prefix_jpg
[ -z $prefix_png ] && prefix_png=$(date +%F)
[ -z $prefix_jpg ] && prefix_jpg=$(date +%F)
rename_file $1 "$prefix_png" "$prefix_jpg"
```

EXERCISE 11
```
#!/bin/sh
INPUT=$1
cd path-to-bin-dir
case $INPUT in
    start)
        ./mongod -f ../../mongod.conf &
        echo "Mongodb server Start"
        ;;
    stop)
        PID_ID=$(ps -ef | grep mongo | cut -d" " -f3 | sed '1!d')
        kill $PID_ID
        if [ $? -eq '0']
            echo "Mongodb server Stop"
        fi
        ;;
    *)
        echo "Error input"
        ;;
    esac
```

EXERCISE 12
```
#!/bin/sh
MESSAGE="Random number is:$RANDOM"
MESSAGE2="Random number is:$(shuf -i 100-800 -n 1)"
echo -e "$MESSAGE\n$MESSAGE2"
```

EXERCISE 13
```
#!/bin/sh
# https://stackoverflow.com/questions/38342992/what-does-ex-option-used-in-bash-bin-bash-ex-mean
#!/bin/bash -ex
ls $HOME/.config
ls $HOME/.config/bla
ls $HOME/.vim
```

